---
title: "Testing, linting and formatting"
format: 
    revealjs:
        slide-number: true
footer: Python package development
logo: academy_logo.png
---

## Testing

Verify code is working as expected.

Simplest way to test is to run code and check output.

. . .

**Automated** testing checks output automatically.

Code changes can break other parts of code.

Automatic testing verifies code is still working.


## Testing workflow

```{mermaid}
flowchart TD
    A[Prepare inputs]
    B[Describe expected output]
    C[Obtain actual output]
    D[Compare actual and\n expected output]

    A --> B --> C --> D
```


## Unit testing

::: {.callout-note}
## Definition "Unit"

* A small, fundamental piece of code.
* Executed in isolation with appropriate inputs.
::: 

::: {.incremental}
* A function is typically considered a "unit"
* Lines of code within functions are smaller (can't be isolated)
* Classes are considered bigger (but can be treated as units)
:::


## A **good** unit test {.smaller}

:::: {.columns}

::: {.column width=70%}

::: {.incremental}
* Fully automated (next week)
* Has full control over all the pieces running ("fake" external dependencies)
* Can be run in any order 
* Runs in memory (no DB or file access, for example)
* Consistently returns the same result (no random numbers)
* Runs fast
* Tests a single logical concept in the system
* Readable
* Maintainable
* Trustworthy
:::

:::

::: {.column width="30%"}


[![](https://images.manning.com/360/480/resize/book/6/5b5ac1d-637b-4f00-9f5d-7fb583b6dac5/Osherove-UT-3ed-MEAP-HI.png)](https://www.artofunittesting.com/)

:::

::::




## Example

1. get a timeseries of water levels
2. find the maxiumum water level each year
3. create a summary report for the subset of data

---

1. get a timeseries of water levels

```python
def test_get_water_level_includes_start_and_end():
    wl = get_water_level(time="2019-01-01", location="Aarhus")
    
    assert len(wl) == 25
```

---

2. find the maxiumum water level each year

```python
def test_get_max_water_level():
    ts = TimeSeries([1.0, .., 3.0], start = "2019-01-01")
    max_wls = get_max_water_level(ts, freq="Y")
    
    assert len(max_wls) == 1
    assert max_wls[0] == 3.0
```

---

3. create a summary report for the subset of data

```python
def test_summary_report():
    max_wls = [1.0, 2.0, 3.0]
    report = summary_report(max_wls)

    assert report.title == "Summary report"
    assert report.text == "The maximum water level in 2021 was 3.0 m"
```

## Integration testing


```python
def test_integration():
    wl = get_water_level(time="2019-01-01", location="Aarhus")
    max_wls = get_max_water_level(wl, freq="Y")
    report = summary_report(max_wls)

    assert report.title == "Summary report"
    assert report.text == "The maximum water level in 2021 was 3.0 m"
```


## Testing in VS Code

![](images/vs_code_test.png)


## Fixtures

::: {.incremental}

* A piece of code that is used by multiple tests
* Provide data or services to tests
* Defined with @pytest.fixture
* Set up test environment
* Pass fixtures as test arguments

:::


## Fixture example

```python
@pytest.fixture
def water_level():
    return TimeSeries([1.0, .., 3.0], start = "2019-01-01")

def test_get_max_water_level(water_level):
    max_wls = get_max_water_level(water_level, freq="Y")
    
    assert len(max_wls) == 1
    assert max_wls[0] == 3.0
```


## Test coverage

::: {.incremental}

* A measure of how much of your code is tested
* A good test suite should cover all the code
* Install `pytest-cov`
* Run tests with coverage report
    - `pytest --cov=myproj`
* Use coverage report to identify untested code

:::


## Test coverage report
```bash
pytest --cov=myproj tests/
```


```bash
-------------------- coverage: ... ---------------------
Name                 Stmts   Miss  Cover
----------------------------------------
myproj/__init__          2      0   100%
myproj/myproj          257     13    94%
myproj/feature4286      94      7    92%
----------------------------------------
TOTAL                  353     20    94%
```






## Testing advice

::: {.callout-tip}
## Test edge cases

- empty lists
- lists with a single element
- empty strings
- empty dictionaries
- None
- np.nan

::: 

## Tests act as specification

```python
def test_operable_period_can_be_missing():

    assert is_operable(height=1.0, period=None)
    assert is_operable(height=1.0, period=np.nan)
    assert is_operable(height=1.0)
    assert not is_operable(height=11.0)

def test_height_can_not_be_missing():

    with pytest.raises(ValueError) as excinfo:
        is_operable(height=None)
        is_operable(height=np.nan)
        
    assert "height" in str(excinfo.value)
```

## Test driven development

::: {.incremental}

1. Write a test that fails ‚ùå
2. Write the code to make the test pass ‚úÖ
3. Refactor the code ‚öíÔ∏è

:::


. . .

The benefit of this approach is that you are forced to think about the expected behaviour of your code before you write it.

It is also too easy to write a test that passes without actually testing the code.


##

::: {.r-fit-text}

and now for
 something completely different...

:::

## [The Zen of Python](https://peps.python.org/pep-0020/) {.smaller}
Beautiful is better than ugly.

Explicit is better than implicit.

Simple is better than complex.

Complex is better than complicated.

Flat is better than nested.

Sparse is better than dense.

Readability counts.

. . .

...

**Errors should never pass silently.**

**Unless explicitly silenced.**

...


## Exceptions {.smaller}

::: {.incremental}
* Exceptions are a way to handle errors in your code.
* Raising an exception can prevent propagating bad values. 
* Exceptions are *communication* between the programmer and the user.
* There are many built-in exceptions in Python
    + `IndexError`
    + `KeyError`
    + `ValueError`
    + `FileNotFoundError`
* You can also create your own custom exceptions, e.g. `ModelInitialistionError`, `MissingLicenseError`?

:::


## Example {.smaller}

```{.python filename="src/ops.py"}
def is_operable(height:float, period:float) -> bool:
    if height < 0.0:
        raise ValueError(f"Supplied value of {height=} is unphysical.")

>>> is_operable(height=-1.0, period=4.0)

Traceback (most recent call last):
  ...
ValueError: Supplied value of height=-1.0 is unphysical.
```

. . .

It is better to raise an exception (that can terminate the program), than to propagate a bad value.


## Warnings 

Warnings are a way to alert users of your code to potential issues or usage errors without actually halting the program's execution.

```{.python filename="src/ops.py"}
import warnings
warnings.warn("This is a warning")
```


## [How to test exceptions](https://docs.pytest.org/en/7.2.x/how-to/assert.html#assertions-about-expected-exceptions)

```{.python filename="tests/test_ops.py"}
import pytest
from ops import is_operable

def test_negative_heights_are_not_valid():
    with pytest.raises(ValueError):
        is_operable(height=-1.0, period=4.0)
```

The same can be done with warnings.


## Linting

A way to check your code for common errors and style issues.

[`ruff`](https://beta.ruff.rs/docs/) is a new tool for linting Python code.

* syntax errors
* unused imports
* unused variables
* undefined names
* code style (e.g. line length, indentation, whitespace, etc.)


## Linting with ruff {.smaller}

```{.python code-line-numbers="|1|6|7" filename="examples/04_testing/process.py"}
import requests
import scipy

def preprocess(x, y, xout):

    x = x[~np.isnan(x)] 
    method = "cubic"
    # interpolate missing values with cubic spline
    return scipy.interpolate.interp1d(x, y)(xout)
```

Run `ruff`:

```bash
$ ruff process.py
process.py:1:8: F401 [*] `requests` imported but unused
process.py:6:12: F821 Undefined name `np`
process.py:7:5: F841 [*] Local variable `method` is assigned to but never used
Found 3 errors.
[*] 2 potentially fixable with the --fix option.
```

::: {.notes}
* Linting is a fast way to find common errors.
* Unused imports are confusing.
* Unused and undefined variables are usually a typo or a mistake. Fixing them can prevent bugs.

:::


## Formatting

::: {.incremental}

* Formatting code for readability and maintainability is essential.
* black is an opinionated automatic code formatter for Python.
* It enforces its own rules for formatting, which are not configurable.
* Having a unified style makes code changes easier to understand and collaborate on.

:::


## Running Black

```bash
$ black .
reformatted data_utils.py
reformatted dfsu/__init__.py
reformatted dataarray.py
reformatted dataset.py
reformatted spatial/geometry.py
reformatted pfs/pfssection.py

All done! ‚ú® üç∞ ‚ú®
6 files reformatted, 27 files left unchanged.
```


## Running Black {.smaller}

Visual Studio Code can be configured to run `black` automatically when saving a file using the `Black` extension.

![](images/vs_code_format.png)

  



