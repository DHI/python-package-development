---
title: "Python types, interfaces and protocols"
format: 
    revealjs:
        slide-number: true
footer: Python package development
logo: academy_logo.png
---

## Types

**C#**

```{.csharp code-line-numbers="1-4"}
int n = 2;
String s = "Hello";

public String RepeatedString(String s, int n) {
    return Enumerable.Repeat(s, n).Aggregate((a, b) => a + b);
}
```

. . . 

**Python**

```{.python code-line-numbers="1-4"}
n = 2
s = "Hello"

def repeated_string(s, n):
    return s * n
```

## Types

::: {.incremental}
* Python is a dynamically typed language
* Types are not checked at compile time
* Types are checked at runtime
:::

. . .

**Python** with type hints

```python
n: int = 2
s: str = "Hello"

def repeated_string(s:str, n:int) -> str:
    return s * n
```


## Abstraction

:::: {.columns}

::: {.column}
**Version A**
```python
total = 0.0
for x in values:
    total = total +x
```

:::


::: {.column}
**Version B**
```python
total = sum(values)
```
:::
::::

. . . 

::: {.incremental}

* Using functions, e.g. `sum()` allows us to operate on a higher level of abstraction.
* Too little abstraction will force you to write many lines of boiler-plate code
* Too much abstraction limits the flexibility
* ✨Find the right level of abstraction!✨

:::


::: {.notes}
* Which version is easiest to understand?
* Which version is easiest to change?
:::


## Collections Abstract Base Classes

```{mermaid}
classDiagram
    Container <|-- Collection
    Sized <|-- Collection
    Iterable <|-- Collection
   
    class Container{
        __contains__(self, x)
    }

    class Sized{
        __len__(self)
    }

    class Iterable{
        __iter__(self)
    }
```

. . .

::: {.incremental}

* If a class implements `__len__` it is a `Sized` object.
* If a class implements `__contains__` it is a `Container` object.
* If a class implements `__iter__` it is a `Iterable` object.
:::

## Collections Abstract Base Classes {.smaller}

```{.python code-line-numbers="1|2-5|6-9|10-11|12-25"}
>>> a = [1, 2, 3]
>>> 1 in a
True
>>> a.__contains__(1)
True
>>> len(a)
3
>>> a.__len__()
3
>>> for x in a:
...     v.append(x)
>>> it = a.__iter__()
>>> next(it)
1
>>> next(it)
2
>>> next(it)
3
>>> next(it)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

## Collections Abstract Base Classes


```{mermaid}

classDiagram
    Container <|-- Collection
    Sized <|-- Collection
    Iterable <|-- Collection
    Collection <|-- Sequence
    Collection <|-- Set
    Sequence <|-- MutableSequence
    Mapping <|-- MutableMapping
    Collection <|-- Mapping

    MutableSequence <|-- List
    Sequence <|-- Tuple
    MutableMapping <|-- Dict
```


## Pythonic

If you want your code to be Pythonic, you have to be familiar with these types and their methods.

Dundermethods:

* `__getitem__`
* `__setitem__`
* `__len__`
* `__contains__`
* ... 

---


```python
class JavaLikeToolbox:
    
    def getToolByName(self, name: str) -> Tool:
        for tool in self.tools:
            if tool.name == name:
                return tool

    def numberOfTools(self) -> int:
        return len(self.tools)

>>> tb = JavaLikeToolbox([Hammer(), Screwdriver()])
>>> tb.getToolByName("hammer")
Hammer()
>>> tb.numberOfTools()
2
```


---

```python
class Toolbox:

    def __getitem__(self, name: str) -> Tool:
        return self._tools[name]
    
    def __len__(self) -> int:
        return len(self.tools)

>>> tb = Toolbox([Hammer(), Screwdriver()])
>>> tb["hammer"]
Hammer()
>>> len(tb)
2
```

::: {.notes}
You want your code to be feel like the built-in types.
:::


## Duck typing

::: {.incremental}

* "*If it walks like a duck and quacks like a duck, it's a duck*"
* From the perspective of the caller, it doesn't matter if it is a rubber duck or a real duck.
* The type of the object is **not important**, as long as it has the right methods.

:::


---

An example is a Scikit learn transformers

* `fit`
* `transform`
* `fit_transform`

If you want to make a transformer compatible with sklearn, you have to implement these methods.

---

```python
class MyTransformer:
    def fit(self, X, y=None):
        # do something
        return self

    def transform(self, X):
        # do something
        return X

    def fit_transform(self, X, y=None):
        return self.fit(X, y).transform(X)
```

---

```python
from sklearn.base import TransformerMixin

class MyOtherTransformer(TransformerMixin):
    def fit(self, X, y=None):
        # do something
        return self

    def transform(self, X):
        # do something
        return X

    # def fit_transform(self, X, y=None):
    # we get this for free, from TransformerMixin
```

## Let's revisit the (date) Interval^[https://martinfowler.com/eaaDev/Range.html]

```{.python code-line-numbers="6-7|11-14"}
class Interval:
    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __contains__(self, x):
        return self.start < x < self.end

>>> dr = Interval(date(2020, 1, 1), date(2020, 1, 31))

>>> date(2020,1,15) in dr
True
>>> date(1970,1,1) in dr
False
```

## Some other interval

```{.python code-line-numbers="9-14"}
class Interval:
    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __contains__(self, x):
        return self.start < x < self.end
    
>>> interval = Interval(5, 10)

>>> 8 in interval
True
>>> 12 in interval
False
```

. . .

As long as the `start`, `end` and `x` are comparable, the `Interval` class is a generic class able to handle integers, floats, dates, datetimes, strings ...

## Time for a discussion {.smaller}

Pre-work for this Module

> Read chapters
>
> 3. Abstraction and encapsulation
>
> 4. Designing for high performance
> 
> in Hillard, 2020
>
> Do you need to understand every single line of code you use, or is it sometimes enough to treat functions as a black box?
> 
> Consider the implications of storing data in a list or in a dictionary.

## Time for a discussion

*Discuss in learning teams (15 minutes):*

**Chapter 3: Abstraction and encapsulation**

What are some pros/cons of treating functions as black boxes?

. . .

**Chapter 4: Designing for high performance**

What is the performance impact of using a list instead of a dictionary?

. . .

*After break out session:*

One person from each team briefly presents their discussion outcomes



## Protocols

::: {.incremental}

* Protocols were introduced in Python 3.8
* Protocols are a way to define a set of methods that a class must implement
* Protocols are not checked at runtime
* Protocols can be used for static type checking (mypy)
* Protocols are a hint to the developer

:::

## Protocols {.smaller}


```{.python}
from dataclasses import dataclass
from typing import Protocol, List
import matplotlib.pyplot as plt


@dataclass
class Station:
    name: str
    longitude: float
    latitude: float


class StationRepository(Protocol):
    def __getitem__(self, key: str) -> Station:
        ...


def plot_stations(station_ids: List[int], repo: StationRepository) -> None:
    for id in station_ids:
        station = repo[id]
        plt.plot(station.longitude, station.latitude, "o")
        plt.text(station.longitude, station.latitude, station.name)
```

## Protocols {.smaller}

```{.python code-line-numbers="1-2|11-12|18-19"}
class DictStationRepository:  # useful for testing (Module 4)
    def __getitem__(self, key: int) -> Station:
        stations = {
            42: Station("Antwerp", 4.42, 51.22),
            365: Station("Brussels", 4.35, 50.85),
            182: Station("Ghent", 3.72, 51.05),
        }
        return stations[key]


class FileStationRepository:
    def __getitem__(self, key: int) -> Station:
        df = pd.read_csv("stations.csv", index_col="id")
        row = df.loc[key]
        return Station(row["name"], key, row["longitude"], row["latitude"])


class DatabaseStationRepository:
    def __getitem__(self, key: int) -> Station:
        # read from database
        station = read_from_db(key)
        return station
```

## Protocols

```python
repo = DictStationRepository()
# repo = FileStationRepository()

plot_stations([42, 365], repo=repo)
```

. . .

Protocols allows to work with abstract types, without having to know the implementation details.

This is useful for testing, but allows for more flexible code.


## Postel's law
a.k.a. the Robustness principle of software design

1. Be liberal in what you accept
2. Be conservative in what you send

. . .

```python
def process(number: Union[int,str,float]) -> int:
    # make sure number is an int from now on
    number = int(number)

    result = number * 2
    return result   
```

##

![](images/postel_meme.jpg)

. . .

The consumers of your package (future self), will be grateful if you are not overly restricitive in what types you accept as input.



## Refactoring

::: {.incremental}

* Refactoring is a way to improve the design of existing code
* Changing a software system in such a way that it **does not alter the external behavior of the code**, yet improves its internal structure
* Refactoring is a way to make code more readable and maintainable
* Housekeeping

:::


## Common refactoring techniques:

* Extract method
* Extract variable
* Rename method
* Rename variable
* Rename class
* Inline method
* Inline variable
* Inline class

## Rename variable

**Before**

```python
n = 0
for v in y:
    if v < 0:
        n = n + 1
```

. . .

**After**

```python
FREEZING_POINT = 0.0
n_freezing_days = 0
for temp in daily_max_temperatures:
    if temp < FREEZING_POINT:
        n_freezing_days = n_freezing_days + 1 
```


## Extract variable

**Before**

```python
def predict(x):
    return min(0.0, 0.5 + 2.0 * min(0,x) + (random.random() - 0.5) / 10.0)
```

. . .

**After**

```python
def predict(x):
    scale = 10.0
    error = (random.random() - 0.5) / scale)
    a = 0.5
    b = 2.0 
    draft = a + b * x + error
    return  min(0.0, draft)
```

## Extract method

```python
def error(scale):
    return (random.random() - 0.5) / scale)

def linear_model(x, *, a=0.0, b=1.0):
    return a + b * x

def clip(x, *, min_value=0.0):
    return min(min_value, x)

def predict(x): 
    draft = linear_model(x, a=0.5, b=2.0) + error(scale=10.0)
    return clip(draft, min_value=0.)
```

## Inline method

Opposite of extract mehtod.


```{.python code-line-numbers="3"}
def predict(x): 
    draft = linear_model(x, a=0.5, b=2.0) + error(scale=10.0)
    return min(0.0, x)
```


## Composed method

Break up a long method into smaller methods.

---

```python
# get data
os.shutil.copyfile(thisfile, localfile)
df = read_csv(localfile)

# clean data
df.dropna()
df.drop_duplicates()
df[somevar<0.0] = 0.0

# transform data
df.date = pd.to_datetime(df.date) - 86400

# predict
predictions = df.height + df.weight * df.age
```



---

```python

def get_data(filename,...):
    ...

def clean_data(df):
    ...

def transform_data(df):
    ...

def predict(df):
    ...

def main():
    df = get_data("raw_data.csv")
    clean_data = clean_data(df)
    final_data = transform_data(clean_data)
    predictions = predict(final_data)
```

## Composed method^[https://wiki.c2.com/?ComposedMethod]

* Divide your program into methods that perform one identifiable task
* Keep all of the operations in a method at the same level of abstraction.
* This will naturally result in programs with many small methods, each a few lines long.
* When you use Extract method a bunch of times on a method the original method becomes a Composed method.


---

:::: {.columns}


::: {.column}

![](images/refactoring_book.png)

:::

::: {.column}

If you want to learn more about refactoring, I recommend the book "Refactoring: Improving the Design of Existing Code" by Martin Fowler.

:::

::::

# Homework {.smaller}

1. Create a new branch on your project with a new feature

2. Create a class which is relevant to the domain of your project, please note that this is simply a starting point, not the final product.

3. Create at least one public method

4. Create at least one public property

5. Make use of one or more private (helper) methods in the public method and/or property

6. Commit code incrementally as you create it, the first commit should not be complete

7. Create a pull request with a short description of this "feature"

8. Ask for reviews from one of your peers as well as the instructor assigned to your project

. . .

 **And don't forget to do the Quiz!**