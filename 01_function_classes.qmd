---
title: Function, classes and modules
format: revealjs
footer: Python package development
logo: campus_logo.png
---


## Functions as black boxes

```{mermaid}
flowchart LR
    A(Input A) --> F["Black box"]
    B(Input B) -->  F
    F --> O(Output)

    style F fill:#000,color:#fff,stroke:#333,stroke-width:4px
```  

::: {.incremental}
* A function is a black box that takes some input and produces some output.
* The input and output can be anything, including other functions.
* As long as the input and output are the same, the function body can be modified.
:::





---

```{mermaid}
flowchart LR
    A(height: 5.0) --> F[is_operable]
    B(period: 3.0) -->  F
    F --> O(True)
```

. . .

```{mermaid}
flowchart LR
    A(height: 15.0) --> F[is_operable]
    B(period: 3.0) -->  F
    F --> O(False)
```

. . .

```python
def is_operable(height, period):
    return height < 10.0 and period > 4.0
```

. . .

This function behaves the same to the caller, but the implementation is different.

```python
def is_operable(height, period):
    model = load_fancy_ml_model()
    return model.predict(height, period)
```


## Pure functions

A pure function returns the same output for the same input.

```python
def f(x)
    return x**2

>> f(2)
4
>> f(2)
4
```
---

A non-pure function can return different outputs for the same input.

```python
n = 0

def non_pure_function(x):
    global n=n+1
    return x + n

>>> non_pure_function(2)
3
>>> non_pure_function(2)
4
```

## Side effects

A function can have side effects, which are changes to the state of the program.

```python
def f_with_side_effect(x):
    with file("output.txt", "w") as f:
        f.write(x)
    return x**2
```

## 

Pure functions with no side effects are easier to reason about.

But sometimes side effects are necessary.

## Modifying input arguments

```{.python code-line-numbers="3"}
def difficult_function(values):
    for i in range(len(values)):
        values[i] = min(0, values[i]) # 😟
    return values

>>> x = [1,2,-1]
>>> difficult_function(x)
>>> x
[0,0,-1]
```

---

Functions that doesn't modify the input arguments are easier to reason about.

But being safe, can incur a performance penalty.

```python
def easier_function(values):
    from copy import deepcopy

    lvalues = deepcopy(values) # 🤔
    for i in range(len(lvalues)):
        lvalues[i] = min(0, lvalues[i])
    return lvalues

>>> x = [1,2,-1]
>>> easier_function(x)
>>> x
[1,2,-1]
```




## Arguments

Positional arguments

```python
def f(x, y):
    return x + y

>>> f(1, 2)
3
```

---

Keyword arguments

```python
def f(x, y):
    return x + y

>>> f(x=1, y=2)
3
```

---

## Positional arguments {.smaller}

::: {.columns}

::: {.column}

**Version 1**

```python
def is_operable(height, period):

    return height < 10.0 and period > 4.0

>>> is_operable(5.0, 5.0)
True
```

:::

::: {.column}

**Version 2**

```python
def is_operable(period, height):
    # dont forget, that arguments are swapped 👍
    return height < 10.0 and period > 4.0

>>> is_operable(5.0, 5.0)
False 😟
```

:::

::::


## Keyword only arguments

```python
def f(*, x, y):
    return x + y

>>> f(1,2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: f() takes 0 positional arguments but 2 were given
```
---  

Optional (default) arguments

```python
def f(x, n=2):
    return x**n

>>> f(2)
4
>>> f(2, n=3)
8
```

. . . 

Makes it easy to use a function with many arguments.


---

Mutable default arguments is a recipe for disaster 😟

```python
def add_to_cart(x, cart=[]):
    cart.append(x)
    return cart

>>> add_to_cart(1, cart=[2])
[2, 1]

>>> add_to_cart(1)
[1]
>>> add_to_cart(2)
[1, 2]
```

---

```python
def add_to_cart_safe(x, cart=None):
    if cart is None:
        cart = []
    cart.append(x)
    return cart
```




## Type hints

Python is a dynamically typed language -> the type of a variable is determined at runtime.

. . .

But we can add type hints to help the reader (and the code editor).

```python
def is_operable(height: float, period: float) -> bool:
    ...
```

---

```python
def clip(values: Iterable[Real],*, threshold=0) -> List[Real]:
    return [min(threshold, v) for v in values]

```

. . .

```python
>>> x= [-1, 0, 2]
>>> clip(x)
[0, 0, 2]
>>> x
[-1, 0, 2]
>>> clip(x, threshold=1)
[0, 0, 1]
>>> x
[-1, 0, 2]
```

## Classes

```python
class WeirdToolbox
    tools = [] # class variable ☹️


>>> t1 = WeirdToolbox()
>>> t1.tools.append("hammer")
>>> t1.tools
["hammer"]

>>> t2 = WeirdToolbox()
>>> t2.tools.append("screwdriver")
>>> t2.tools
["hammer", "screwdriver"]
```

## Classes

```python
class Toolbox
    def __init__(self):
        self.tools = [] # instance variable 😃

>>> t1 = Toolbox()
>>> t1.tools.append("hammer")
>>> t1.tools
["hammer"]

>>> t2 = Toolbox()
>>> t2.tools.append("screwdriver")
>>> t2.tools
["screwdriver"]
```


## Static methods

```python
from datetime import date

class Interval:
    def __init__(self, start:date, end:date):
        self.start = start
        self.end = end

>>> dr = Interval(date(2020, 1, 1), date(2020, 1, 31))
>>> dr.start
datetime.date(2020, 1, 1)
>>> dr.end
datetime.date(2020, 1, 31)
```


## Static methods

```python
class Interval:
    def __init__(self, start:date, end:date):
        self.start = start
        self.end = end

    @staticmethod
    def from_string(date_string):
        start_str, end_str = date_string.split("|")
        start = start_str.fromisoformat()
        end = end_str.fromisoformat()
        return Interval(start, end)

>>> dr = Interval.from_string("2020-01-01|2020-01-31")
```

## Dataclasses

```python
from dataclasses import dataclass

@dataclass
class Interval:
    start: date
    end: date

    @staticmethod
    def from_string(date_string):
        start, end = date_string.split("|")
        start = date.fromisoformat(start)
        end = date.fromisoformat(end)
        return Interval(start, end)

>>> dr = Interval.from_string("2020-01-01|2020-01-31")
>>> dr
Interval(start=datetime.date(2020, 1, 1), end=datetime.date(2020, 1, 31))
```

---

```python
@dataclass
class Interval:
    start: date
    end: date

    def __str__(self):
        return f"{self.start} | {self.end}"

>>> dr = Interval(start=date(2020, 1, 1), end=date(2020, 1, 31))
>>>print(dr)
2020-01-01 | 2020-01-31
```

## Equality

On a regular class, equality is based on the memory address of the object.

```python
class Interval:
    def __init__(self, start:date, end:date):
        self.start = start
        self.end = end

>>> dr1 = Interval(start=date(2020, 1, 1), end=date(2020, 1, 31))
>>> dr2 = Interval(start=date(2020, 1, 1), end=date(2020, 1, 31))
>>> dr1 == dr2
False
```

---


```python
class Interval:
    def __init__(self, start:date, end:date):
        self.start = start
        self.end = end

    def __eq__(self, other):
        return self.start == other.start and self.end == other.end

>>> dr1 = Interval(start=date(2020, 1, 1), end=date(2020, 1, 31))
>>> dr2 = Interval(start=date(2020, 1, 1), end=date(2020, 1, 31))
>>> dr1 == dr2
True
```

---

For a dataclass, equality is based on the values of the fields.

```python
@dataclass
class Interval:
    start: date
    end: date

>>> dr1 = Interval(start=date(2020, 1, 1), end=date(2020, 1, 31))
>>> dr2 = Interval(start=date(2020, 1, 1), end=date(2020, 1, 31))
>>> dr1 == dr2
True
```


## Modules

Modules are files containing Python code (functions, classes, constants) that belong together.

```
$tree analytics/
analytics/
├── __init__.py
├── date.py
└── tools.py
```

. . .

The analytics package contains two modules:

* `tools` module
* `date` module

---

```python
from analytics.tools import is_operable
from analytics.tools import Toolbox, Tool
from analytics.date import Interval

tool = Tool(name="hammer")
dr = Interval(start=date(2020, 1, 1), end=date(2020, 1, 31))
is_operable(height=1.8, period=1.0)
```






