---
title: Function, classes and modules
format: revealjs
---


## Functions as black boxes

```{mermaid}
flowchart LR
    A(Input A) --> F["Black box"]
    B(Input B) -->  F
    F --> O(Output)

    style F fill:#000,color:#fff,stroke:#333,stroke-width:4px
```  

::: {.incremental}
* A function is a black box that takes some input and produces some output.
* The input and output can be anything, including other functions.
* As long as the input and output are the same, the function body can be modified.
:::





---

```{mermaid}
flowchart LR
    A(height: 5.0) --> F[is_operable]
    B(period: 3.0) -->  F
    F --> O(True)
```

. . .

```{mermaid}
flowchart LR
    A(height: 15.0) --> F[is_operable]
    B(period: 3.0) -->  F
    F --> O(False)
```

. . .

```python
def is_operable(height, period):
    return height < 10.0 and period < 4.0
```

. . .

This function behaves the same to the caller, but the implementation is different.

```python
def is_operable(height, period):
    model = load_fancy_ml_model()
    return model.predict(height, period)
```


## Pure functions

A pure function returns the same output for the same input.

```python
def f(x)
    return x**2

>> f(2)
4
>> f(2)
4
```
---

A non-pure function can return different outputs for the same input.

```python
n = 0

def non_pure_function(x):
    global n=n+1
    return x + n

>>> non_pure_function(2)
3
>>> non_pure_function(2)
4
```

## Side effects

A function can have side effects, which are changes to the state of the program.

```python
def f_with_side_effect(x):
    with file("output.txt", "w") as f:
        f.write(x)
    return x**2
```

## 

Pure functions with no side effects are easier to reason about.

But sometimes side effects are necessary.

## Modifying input arguments

```{.python code-line-numbers="3"}
def difficult_function(values):
    for i in range(len(values)):
        values[i] = min(0, values[i]) # ðŸ˜Ÿ
    return values

>>> x = [1,2,-1]
>>> difficult_function(x)
>>> x
[0,0,-1]
```

---

Functions that doesn't modify the input arguments are easier to reason about.

But being safe, can incur a performance penalty.

```python
def easier_function(values):
    from copy import deepcopy

    lvalues = deepcopy(values) # ðŸ¤”
    for i in range(len(lvalues)):
        lvalues[i] = min(0, lvalues[i])
    return lvalues

>>> x = [1,2,-1]
>>> easier_function(x)
>>> x
[1,2,-1]
```




## Arguments

Positional arguments

```python
def f(x, y):
    return x + y

>>> f(1, 2)
3
```

---

Keyword arguments

```python
def f(x, y):
    return x + y

>>> f(x=1, y=2)
3
```

. . .

Keyword only arguments

```python
def f(*, x, y):
    return x + y

>>> f(1,2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: f() takes 0 positional arguments but 2 were given
```
---  

Optional (default) arguments

```python
def f(x, n=2):
    return x**n

>>> f(2)
4
>>> f(2, n=3)
8
```

. . . 

Makes it easy to use a function with many arguments.


---

Mutable default arguments is a recipe for disaster ðŸ˜Ÿ

```python
def add_to_cart(x, cart=[]):
    cart.append(x)
    return cart

>>> add_to_cart(1, cart=[2])
[2, 1]

>>> add_to_cart(1)
[1]
>>> add_to_cart(2)
[1, 2]
```

---

```python
def add_to_cart_safe(x, cart=None):
    if cart is None:
        cart = []
    cart.append(x)
    return cart
```




## Type hints

Python is a dynamically typed language -> the type of a variable is determined at runtime.

. . .

But we can add type hints to help the reader (and the code editor).

```python
def is_operable(height: float, period: float) -> bool:
    ...
```

---

```python
def clip(values: Iterable[Real],*, threshold=0) -> List[Real]:
    return [min(threshold, v) for v in values]

```

. . .

```python
>>> x= [-1, 0, 2]
>>> clip(x)
[0, 0, 2]
>>> x
[-1, 0, 2]
>>> clip(x, threshold=1)
[0, 0, 1]
>>> x
[-1, 0, 2]
```